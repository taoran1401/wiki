## 软件开发方法

软件开发方法是软件开发的方法学

### 信息系统的开发方法

- 结构化系统分析与设计方法（SSA&D）
  - 基本思想是：用系统的思想，系统工程的方法，按用户至上的原则，结构化、模块化、自顶向下对信息系统进行分析与设计；
  - 严格区分工作阶段，每阶段有任务和结果；强调系统开发过程的整体性和全局性；系统开发过程工程化，文档资料标准化。
  - 自顶向下的开发方式，适用于那些需求明确，但技术难度不大的系统开发
  - 面向数据流的方法

> 结构化方法使用的主要分析设计工具是“程序流程图、数据流程图等”

- 原型方法
  - 基本思想是：凭借着系统分析人员对用户要求的理解，在软件环境支持下，快速地给出一个实实在在的模型（或称为原型、雏形），然后与用户反复协商修改，最终形成实际系统。
  - 适用于需求不明确的情况。

- 面向对象的开发方法（OO）
  - 出发点和基本原则是：尽可能模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界、解决问题的方法与过程；
  - 更好的复用性；关键在于建立一个全面、合理、统一的模型；
  - 分析、设计、实现三个阶段，界限不明确。

- 面向服务的开发方法 SOA
  - 以粗粒度、松散耦合和标准的服务为基础，加强了系统的可复用性和可演化性
  - SO方法有三个主要的抽象级别：操作、服务、业务流程
  - SOAD分为三个层次：
    - 基础设计层（底层服务构件）
    - 应用结构层（服务之间的接口和服务级协定）
    - 业务组织层（业务流程建模和服务流程编排）
  - 服务建模：分为服务发现、服务规约和服务实现三个阶段

### 软件生命周期

在 GB8566-88（《软件工程国家标准——计算机软件开发规范》）中将软件生命周期划分为 8 个阶段`(书6.1)`：
- 可行性研究与计划
- 需求分析
- 概要设计
- 详细设计
- 实现
- 集成测试
- 确认测试
- 使用和维护


### 软件开发模型
- 瀑布模型：迭代模型/迭代开发方法；适合需求明确的项目
- 演化模型：快速应用开发
- 增量模型：构建组装模型/基于构建的开发方法
- 螺旋模型：统一过程/统一开发方法
- 原型模型：敏捷开发方法
- 喷泉模型：模型驱动的开发方法
- V模型：基于架构的开发方法


### 瀑布模型

![](../../static/images/sw_001.jpg)

- 瀑布模型是一个特别经典的，老套的周期模型。工序简化，将功能实现和设计分开。便于分工协作。
- 一般情况下将软件开发周期分为计划、需求分析、概要设计、详细设计、编码以及单元测试、测试、运行维护等几个阶段。
- 瀑布模型的周期是环环相扣的。每个周期中交互点都是一个里程碑，上一个周期的结束需要输出本次活动的工作结果，本次的活动的工作结果将会作为下一个周期的输入。这样，当某一个阶段出现了不可控的问题的时候，就会导致返工，返回到上一个阶段，甚至会延迟下一个阶段。自上而下、相互衔接的固定次序

优点:

(1)为项目提供了按阶段划分的检查点。
(2)当前一阶段完成后，您只需要去关注后续阶段。
(3)可在迭代模型中应用瀑布模型。
增量迭代应用于瀑布模型。迭代1解决最大的问题。每次迭代产生一个可运行的版本,同时增加更多的功能。每次迭代必须经过质量和集成测试。

缺点:

(1)在项目各个阶段之间极少有反馈。
(2)只有在项目生命周期的后期才能看到结果。
(3)通过过多的强制完成日期和里程碑来跟踪各个项目阶段。
(4)瀑布模型的突出缺点是不适应用户需求的变化。

### 演化模型、增量模型(解决用户需求分析困难)

![](../../static/images/se_046.jpeg)

这两个模型属于原型方法

- 演化模型: 是一种渐进式的原型，即它采取原型的设计模式，但不会将其抛弃，而是在此基础上进一步进行设计
- 增量模型: 是一种递增式设计，将产品一步一步进行设计，每完成一步就交由客户审视，这样也可以使得下一步的设计更为明确

### 螺旋模型

![](../../static/images/sw_002.jpg)


- 螺旋模型 尤其重视风险分析阶段，特别适用于庞大并且复杂，非常高风险的项目。
- 通常螺旋模型由四个阶段组成：制定计划、风险分析、实施工程和客户评估。螺旋模型中，发布的第一个模型甚至可能是没有任何产出的，可能仅仅是纸上谈兵的一个目标，但是随着一次次的交付，每一个版本都会朝着固定的目标迈进，最终得到一个更加完善的版本

### V模型,喷泉模型，RAD模型

![](../../static/images/sw_003.jpg)

#### v模型
测试贯穿于始终的模型

- V模型从整体上看起来，就是一个V字型的结构，由左右两边组成。
- 左边的下划线分别代表了需求分析、概要设计、详细设计、编码。
- 右边的上划线代表了单元测试、集成测试、系统测试与验收测试。
- 看起来V模型就是一个对称的结构，它的重要意义在于，非常明确的表明了测试过程中存在的不同的级别，并且非常清晰的描述了这些测试阶段和开发阶段的对应关系。
 

> 优点：相对于瀑布模型，V模型测试能够尽早的进入到开发阶段。
> 缺点：虽然测试尽早的进入到开发阶段，但是真正进行软件测试是在编码之后，这样忽视了测试对需求分析，系统设计的验证，时间效率上也大打折扣。

#### 喷泉模型

喷泉模型与传统的结构化生存期比较，具有更多的增量和迭代性质，生存期的各个阶段可以相互重叠和多次反复，而且在项目的整个生存期中还可以嵌入子生存期。就像水喷上去又可以落下来，可以落在中间，也可以落在最底部

#### RAD模型

![](../../static/images/sw_004.jpg)

快速应用开发（RAD）模型是一个增量型的软件开发过程模型。强调极短的开发周期。RAD模型是瀑布模型

采用RAD模型的软件通过大量使用可复用构件，采用基于构件的建造方法赢得快速开发。如果需求理解得好且约束了项目的范围，随后是数据建模、过程建模、应用生成、测试及反复。

设计思想：
1. 让用户更主动地参与到系统分析、设计和构造活动中来。
2. 将项目开发组织成一系列重点突出的研讨会，研讨会要让项目投资方、用户、分析员、设计人员和构造人员一同参与。
3. 通过一种迭代的构造方法加速需求分析和设计阶段。
4. 让用户提前看到一个可工作的系统。

### 统一过程(UP/RUP模型)

![](../../static/images/sw_005.jpg)

特点：
- 用例驱动
- 以架构为中心
- 迭代和增量

过程：
- 初始阶段
  - 确定项目范围和边界
  - 识别系统的关键用例
  - 展示系统的候选框架
  - 估计项目费用和时间
  - 评估项目风险
- 细化阶段
  - 分析系统问题领域
  - 建立软件架构基础
  - 淘汰最高风险元素
- 构建阶段
  - 开发剩余构件
  - 构件组装与测试
- 交付阶段
  - 进行β测试
  - 制作发布版本
  - 用户定档定稿
  - 确认新系统
  - 培训和调整产品


### 敏捷方法

基本原则：

短平快的会议
小型版本发布
较少的文档
合作为重
客户直接参与
自动化测试
适应性计划调整
结对编程
测试驱动开发
持续集成
重构

敏捷开发方法：
- 极限编程（XP）：敏捷开发的典型方法之一，是一种轻量级（敏捷）、高效，低风险、柔性、可预测的、科学的软件开发方法，它由价值观、原则、实践和行为4个部分组成。
  - 其中4大价值观为: 沟通、简单性、反馈和勇气。
- 水晶法（Crystal）：水晶方法体系与XP一样，都有以人为中心的理念，但在实践上有所不同。水晶方法体系考虑到人们一般很难严格遵循一个纪律约束很强的过程，认为每一种不同的项目都需要一套不同的策略、约定和方法论。因此，与XP的高度纪律性不同，水晶方法体系探索了用最少纪律约束而仍能成功的方法，从而在产出效率与易于运作上达到一种平衡。也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够接受并遵循它。
- 并列争球法（Scrum）：用迭代的方法，其中把每30天一次的迭代称为一个“冲刺”，并按需求的优先级来实现产品。多个自组织和自治小组并行地递增实现产品。协调是通过简短的日常会议来进行的
- 自适应软件开发（ASD）：ASD的核心是三个非线性的、重迭的开发阶段：猜测，合作与学习。

五大原则：
- 快速反馈
- 简单性假设
- 逐步修改
- 提倡更改
- 优质工作

### 净室工程

- 净室即无尘、洁净室。也就是一个受控污染级别的环境
- 使用盒结构规约(或形式化方法)进行分析和设计建模，并且强调将正确性验证，而不是测试，作为发现和消除错误的主要机制
- 使用统计的测试来获取认证被交付的软件的可靠性所必须的出错率信息

### 逆向工程

不是软件开发方法，只是作为在开发过程中解决某种问题的技术

- 实现级：包括程序的抽象语法树、符号表、过程的设计表示
- 结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构
- 功能级：包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型
- 领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息，例如实体关系模型

## 需求工程

软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。
软件需求是指用户解决问题或达到目标所需的条件或能力，是系统或系统部件要满足合同、标准、规范或其他正式规定文档所需具有的条件或能力，以及反映这些条件或能力的文档说明。

需求开发：
- 需求获取
- 需求分析
- 需求定义
- 需求验证

需求管理
- 变更控制
- 版本控制
- 需求跟踪
- 需求状态跟踪

需求分类
- 技术维度
  - 业务需求
  - 用户需求
  - 系统需求
    - 功能需求
    - 性能需求
    - 设计约束
- 项目管理维度
  - 基本需求
  - 期望需求
  - 兴奋需求

### 需求获取

收集资料
联合讨论会
用户访谈
书面调查
现场观摩
参加业务实践
阅读历史文档
抽样调查

### 需求分析

#### 结构化需求分析(SA)

需求分析是一种软件工程活动，它在系统级软件分配和软件设计间起到桥梁的作用，需求分析使得系统工程师能够刻画出软件的功能和性能，指明软件和其他系统元素的接口，并建立软件必须满足的约束。

需求分析允许系统分析师细化软件的分解，并建立将被软件处理的数据、功能和行为模型。

最后，需求规约为开发者和客户提供了软件开发完成后质量评估的依据。
需求分析为软件设计师提供了可被翻译成数据、架构、界面和过程设计的模型，
需求分析的任务是发现、求精、建模和规约的过程，包括详细地细化由系统工程师建立并在软件项目计划中明确的软件范围，创建所需数据、信息和控制流及操作行为的模型，此外，还要分析可选择的解决方案，并将它们分配到各软件元素中去。
需要注意的是，在需求分析阶段要得到详细的规约是不可能的。客户可能并不能精确地肯定需要什么，开发者可能不能肯定可用什么特定的方法来适当地完成功能和性能。

![](../../static/images/se_006.jpg)

DFD 数据流图:

数据流图DFD是SA方法中的重要工具，是表达系统内部数据的流动并通过数据流描述系统功能的一种方法。 

DFD还可被认为是一个系统模型，在信息系统开发中，如果采用结构化方法，则一般将DFD作为需求规格说明书的一个组成部分。用例模型描述了一组用例、参与者及它们之间的关系。

通常使用数据字典作为该工具的补充说明。

1. DFD是理解和表达用户需求的工具，是需求分析的手段。由于DFD简明易懂，不需要任何计算机专业知识就可以理解它，因此，系统分析师可以通过DFD与用户进行交流。
2. DFD概括地描述了系统的内部逻辑过程，是需求分析结果的表达工具，也是系统设计的重要参考资料，是系统设计的起点。
3. DFD作为一个存档的文字材料，是进一步修改和充实开发计划的依据。

#### 面向对象的需求分析(OOA)

一些概念：
- 对象
- 类
- 抽象
- 封装
- 继承与泛化
- 多态
- 接口
- 消息
- 组件
- 模式和复用

在系统设计过程中，类可以分为三种类型，分别是实体类、边界类和控制类：
1. 实体类: 实体类的主要职责是存储和管理系统内部的信息，它也可以有行为，甚至很复杂的行为，但这些行为必须与它所代表的实体对象密切相关。实体类映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息，例如，在线教育平台系统可以提取出学员类和课程类，它们都属于实体类。实体类通常都是永久性的，它们所具有的属性和关系是长期需要的，有时甚至在系统的整个生存期都需要。
2. 控制类: 控制类用于描述一个用例所具有的事件流控制行为，控制一个用例中的事件顺序。
例如，用例“身份验证”可以对应于一个控制类“身份验证器”，它提供了与身份验证相关的所有操作。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象（控制类的实例）通常控制其他对象，因此，它们的行为具有协调性。通常情况下，控制类没有属性，但一定有方法。
3. 边界类: 边界类用于描述外部参与者与系统之间的交互，它位于系统与外界的交接处，包括所有窗体、报表、打印机和扫描仪等硬件的接口，以及与其他系统的接口。
要寻找和定义边界类，可以检查用例模型，每个参与者和用例交互至少要有一个边界类，边界类使参与者能与系统交互。
边界类是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。
常见的边界类有窗口、通信协议、打印机接囗、传感器和终端等。实际上，在系统设计时，产生的报表都可以作为边界类来处理。

### 需求定义

![](../../static/images/se_020.png)

## UML

统一建模语言言（Unified Modeling Language，UML）是用于系统的可视化建模语言，它将OMT、OOSE 和 Booch 方法中的建模语言和方法有机地融合在一起，是国际统一的软件建模标准。虽然它源于 OO 软件系统建模领域，但由于其内建了大量扩展机制，也可以应用于更多的领域中，例如工作流程、业务领域等。

![](../../static/images/se_007.png)

UML由构造块、公共机制和规则(架构)三个部分构成

- 构造块：基本的UML建模元素(事物)、关系和图
  - 建模元素(事物): 包括结构事物(类、接口、协作、用例、活动类、组件、节点等)、行为事物(代表时间和空间上动作。包括消息，动作次序，连接)、分组事物(包，构件)、注释事物(UML模型的解释部分。描述、说明、标注模型的元素)
  - 关系: 包括关联关系、依赖关系、泛化关系、实现关系
  - 图
- 规则: TODO 有问题，书籍和网络上不是规则书上是架构网络上是其他的
- 图：TODO

### UML图

静态图(结构图)
- 类图：一组类、接口、协作和它们之间的关系
- 对象图：一组对象及它们之间的关系
- 构件图：一个封装的类和它的接口
- 部署图：软硬件之间的映射
- 制品图：系统的物理结构
- 包图：由模型本身分解而成的组织单元，以及它们之间的依赖关系
- 组合结构图

动态图(行为图)
- 用例图：系统与外部参与者的交互
- 顺序图：强调按时间顺序
- 通信图（协作图）
- 状态图：状态转换变迁
- 活动图：类似程序流程图，并行行为
- 定时图：强调实际时间
- 交互概览图

### UML4+1视图

![](../../static/images/se_008.png)

![](../../static/images/sa_92.png)


用例视图（Use Cases View），最初称为场景视图，关注最终用户需求，为整个技术架构的上线文环境.通常用UML用例图和活动图描述。

逻辑视图（Logical view），主要是整个系统的抽象结构表述，关注系统提供最终用户的功能，不涉及具体的编译即输出和部署，通常在UML中用类图，交互图，时序图来表述，类似与我们采用OOA的对象模型。

实现视图(implementation view)，描述软件在开发环境下的静态组织，从程序实现人员的角度透视系统，也叫做开发视图(Development View)。实现视图关注程序包，不仅包括要编写的源程序，还包括可以直接使用的第三方SDK和现成框架、类库，以及开发的系统将运行于其上的系统软件或中间件, 在UML中用组件图，包图来表述。实现视图和逻辑视图之间可能存在一定的映射关系：比如逻辑层一般会映射到多个程序包等。

部署视图(deploymentview), 通常也叫做物理视图（Physical view ），是从系统工程师解读系统，关注软件的物流拓扑结，以及如何部署机器和网络来配合软件系统的可靠性、可伸缩性等要求。部署视图和处理视图的关系：处理视图特别关注目标程序的动态执行情况，而部署视图重视目标程序的静态位置问题；部署视图是综合考虑软件系统和整个IT系统相互影响的架构视图。

处理视图（Process view）(进程视图) 处理视图关注系统动态运行时，主要是进程以及相关的并发、同步、通信等问题。处理视图和开发视图的关系：开发视图一般偏重程序包在编译时期的静态依赖关系，而这些程序运行起来之后会表现为对象、线程、进程，处理视图比较关注的正是这些运行时单元的交互问题，在UML中通常用活动图表述。

### 用例图

![](../../static/images/se_009.png)

### UML关系

![](../../static/images/se_010.png)

![](../../static/images/se_011.png)

### 类图与对象图

![](../../static/images/se_012.png)

![](../../static/images/se_013.jpg)

### 顺序图

![](../../static/images/se_014.png)

### 活动图

![](../../static/images/se_015.png)

泳道式活动图：
![](../../static/images/se_016.png)

### 状态图

![](../../static/images/se_017.png)

![](../../static/images/se_018.png)

### 通信图(协作图)

![](../../static/images/se_019.png)

## 软件系统建模

![](../../static/images/se_021.png)

![](../../static/images/se_022.png)

## 系统设计

### 界面设计

#### 人机界面设计

![](../../static/images/se_023.png)

### 结构化设计

![](../../static/images/se_024.png)

![](../../static/images/se_025.png)

### 面向对象设计

#### 基本过程

![](../../static/images/se_027.png)

#### 设计原则

![](../../static/images/se_028.png)

#### 设计模式的概念
![](../../static/images/se_029.png)

#### 设计模式的分类

![](../../static/images/se_030.png)

创建型:
![](../../static/images/se_031.png)

结构型：
![](../../static/images/se_032.png)

行为型：

图1：
![](../../static/images/se_033.png)

图2：
![](../../static/images/se_035.png)

#### 模式概念

架构模式：软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策

设计模式：主要关注软件系统的设计，与具体的实现语言无关

惯用法：是最低层的模式，关注软件系统的设计与实现，实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。每种编程语言都有它自己特定的模式，即语言的惯用法。例如引用-计数就是C++语言中的一种惯用法

## 软件测试

### 测试类型

![](../../static/images/se_036.png)

### 测试用例设计

![](../../static/images/se_037.png)

### 阶段测试

![](../../static/images/se_038.png)

![](../../static/images/se_039.png)

- 单元测试: 模块测试、模块功能、性能、接口等
- 集成测试：模块间的接口；其测试的技术依据是软件概要设计文档。
- 确认测试：验证软件与需求的一致性。
  - 内部确认测试
  - Alpha测试
  - Beta测试
  - 验收测试
- 系统测试：真实环境下，验证完整的软件配置项能否和系统正确连接
- 回归测试：测试软件变更之后，变更部分的正确性对变更需求的复合型

### 面向对象的测试

![](../../static/images/se_040.png)

## 软件调试

![](../../static/images/se_041.png)
 
## 系统运行与软件维护

### 系统转换计划 - 遗留系统演化策略

![](../../static/images/se_042.png)

![](../../static/images/se_043.png)

### 系统转换计划 - 新旧系统的转换策略

![](../../static/images/se_044.png)

### 运行与维护

![](../../static/images/se_045.png)

- 正确性维护: 指改正在系统开发阶段已发生而系统测试阶段尚未发现的错误
- 适应性维护: 指使应用软件适应信息技术变化和管理需求变化而进行的修改。企业的外部时长环境和管理需求的不断变化也使得各级管理人员不断提出新的信息需求
- 完善性维护: 扩充功能和改善性能而进行的修改。对已有的软件系统增加一些在系统分析和设计阶段中没有规定的功能与性能特征
- 预防性维护: 为了改进应用软件的可靠性和可维护性，为了适应未来的软硬件环境的变化，应主动增加预防性的新的功能，以使用系统适应各类变化而不被淘汰。如将专用报表功能改成通用报表功能生成功能，以适应将来报表格式的变化。

